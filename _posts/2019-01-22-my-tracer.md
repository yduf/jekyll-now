---
published: true
title: Raytracing with Shadertoy
tags: raytracing article
---
Online raytracing tutorial using Shadertoy.

This tutorial is heavily based upon [ssloy/tinyraytracer
](https://github.com/ssloy/tinyraytracer/wiki) and [Ray Tracing in One Weekend]() from [Peter Shirley](https://twitter.com/Peter_shirley) 
It's goal is to have a working raytracer in a minimum of steps.

But rather than doing it offline with c++, I focus on doing it in a webbrowser, using [Shadertoy]().
It has the benefit of making it very interactive, simpler and faster (realtime) because of the use of shader.
And somewhat bit more complicated for complete beginer because of some shadertoy Magic. I let you judge (by refering yourself to the original tutorial).

Using shader allows to use direclty vec3 object that are part of the shading langage. The drawback is that there is no class and only struct and functions can be used.

This tutorial is primary made for myself and follow the same plan than the one I am referring to.
When relevant I kept the same title as the chapter it maches on other tutorials.


## 1 - Generate an image

When creating a new shader on Shadertoy, we get some sample code which is close to the following one. Which is made to get the exact same rendering than in other tutorial.

{% highlight cpp %}
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy;

    // Gradiant x,y varying pixel color
    vec3 col = vec3( uv.y , uv.x, 0);

    // Output to screen
    fragColor = vec4(col,1.0);
}
{% endhighlight %}

_mainImage_  is the equivalent of the render function. It's job is to output for a given screen coordinate an color for this pixel. It uses normalzed coordinates (between 0 and 1). And produce the following output:

<iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/ts2GRh?gui=true&t=10&paused=true&muted=false" allowfullscreen></iframe>

Notice: that the uv coordinates we get has the origine (0,0) at the bottom left, since the color is dark there (which is not necessary the same on the other tutorials).

## 2 - Rays, a simple camera, and background

> At the core of a ray tracer is to
send rays through pixels and compute what color is seen in the direction of those rays. This is
of the form ​ calculate which ray goes from the eye to a pixel, compute what that ray intersects,
and compute a color for that intersection point. ​ When first developing a ray tracer, I always do
a simple camera for getting the code up and running. I also make a simple ​ color(ray) ​ function
that returns the color of the background (a simple gradient).

{% highlight cpp %}
vec3 cast_ray( in vec3 orig, in vec3 dir) {
    // draw sky and land
    if( dir.y > 0.) {        // sky
        return vec3(0., 0., 0.5);
    }
    else {                  // land
        return vec3(0., 0.5, 0.);
    }
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // image coordinate origin (0,0) in middle of image
    // from [-1, 1] on y with ratio preserved, on x
    vec2 uv = fragCoord / iResolution.xy;
    float aspectRatio = iResolution.x / iResolution.y;
    uv = 2.0 * uv - vec2(1.0, 1.0);
    uv.x *= aspectRatio;

    // camera coordinate (pinhole model)
    float focal = 1.0;                  // focal distance
    vec3 origin = vec3( 0, 0, 0);
    vec3 dir    = vec3( uv, -focal);    // ray thrown from the focal point

    // world coordinate == camera coordinate    
    vec3 col = cast_ray( origin, dir);

    // Output to screen
    fragColor = vec4(col,1.0);
}
{% endhighlight %}

<iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/WsBGzD?gui=true&t=10&paused=true&muted=false" allowfullscreen></iframe>


## 3 - ray tracing

Now for each pixel we will form a ray coming from the origin and passing through our pixel, and then check if this ray intersects with the sphere:

![caption](https://camo.githubusercontent.com/ccc20911601b22524a1cc127ea89dfe2f1c100d9/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f382f38332f5261795f74726163655f6469616772616d2e7376673f73616e6974697a653d74727565)

I want to define one sphere in my code and draw it without being obsessed with materials or lighting.

We already have the camera in place, so we just have to check if ray originating from the camera, intersect with the sphere. As camera coordinate and world coordinate are the same we just have to compute ray/sphere intersection. We just had that check to the _cast_ray_ function

{% highlight cpp %}
struct Sphere
{
    // sphere properties
    vec3 center;
    float radius;
};

const Sphere S = Sphere( vec3( 3., 0., -10), 2.);

// https://www.shadertoy.com/view/ldScDc
// sphere intersection
float sphere( in vec3 orig, in vec3 udir, 	// !udir = normlized
              in vec3 center, in float radius) {
    vec3 rc = orig - center;
    float c = dot(rc, rc) - (radius * radius);
    float b = dot(udir, rc);
    float d = b * b - c;
    float t = -b - sqrt(abs(d));
    float st = step(0.0, min(t, d));
    return mix(-1.0, t, st);
}

vec3 cast_ray( in vec3 orig, in vec3 dir) {
    
    // sphere intersection
    if( sphere( orig, dir, S.center, S.radius) > 0.) {
        return vec3(0.2, 0.7, 0.8); // sphere color
    }
    
    // draw sky and land
    if( dir.y > 0.) {        // sky
        return vec3(0., 0., 0.5);
    }
    else {                  // land
        return vec3(0., 0.5, 0.);
    }
}
{% endhighlight %}


<iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/tdSGRW?gui=true&t=10&paused=true&muted=false" allowfullscreen></iframe>


