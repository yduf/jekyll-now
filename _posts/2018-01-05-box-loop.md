---
title: Faster collision check
published: true
tags: collision codingame article math
---
In many small games it is sufficient to check collision between objects,
with 2 imbricated loops (for eg in [Mean-Max]({% post_url 2017-11-27-meanmax %}) referee [code](https://github.com/CodinGame/MeanMax/blob/ca1a77b5bffd3a0ea73e774ab8937d1c9984e2e5/Referee.java#L1273)):
```cpp
for( int i = 0; i < NbObjects; ++i) {
    for( int j = i + 1; j < NbObjects; ++j) {
        getCollisionWith( i, j);
    }
}
```
# The problem
Problem of this double loop, is that:
- it has O(N^2) complexity,
- probably not so many object are colliding, but we are checking them all anyway.

What may be acceptable for the game engine, may become a problem, if you want
to simulate a lot of turns for an AI for that game, especially if the collision check is not trivial, and is a costly function.

To illustrate this simulating 10 000 time a world containign 11 objects with this code lead to:
- 1 000k call to getCollisionWith(),
- approx run time of 25ms

# Looking for a simple solution

([Joel Spolsky](https://www.joelonsoftware.com/2007/11/16/how-to-demo-software/) told me once that if you want to have an entertaining article, you have to tell a good story along the way...)

In codingame contest, there is a limited available time, and if you are porting the referee to an other langage, you already have used a significant amount of time doing this boring task and you may end like me unwilling to do more. 

It was late December, I ended 85th with my ruby code in [Mean-Max]({% post_url 2017-11-27-meanmax %}) contest, already having converted the java referee to Ruby once, I was happy with my rank (it was my initial goal) and having beaten all my collegues :-), but having been 25 sit away from the Legend League at some point in the contest, I wanted more.

When you read the postmortem of the leading guy like [Agade](https://www.codingame.com/forum/t/mean-max-cc01-feedback-strategies/5030/9) and [Robostac](https://github.com/robostac/cg-meanmax-postmortem/blob/master/readme.md) they all seems to use Genetic Algorithm [GA]({% post_url 2018-01-03-GA-vs-ES %}) for their AI. So I was wiling to try to implement one king of GA AI myself to see how it works. But for that kind of AI you need to simulate a lot of move. And so you need some efficient code, since you are limited to 50ms in the contest. 

So at that time the Mean-Max challenge had reopen and I had rewritent everything in C++ (leaving my beloved Ruby) just to ensure performance would not be an issue. So it was my second port of the referee from Java to an other langage (and was quite fed up with it). 

My first attemps with GA, did not give good results (I left stuck in Bronze for a long time). And at some point I thought it was because I was not able to simulate enough generation with my referee port. Profiling it show that most of the time (60%) was spent in the collision check above. So I was looking for a quick win to solve that issue.

I was lying on the Sofa nearby the christmas tree, when Santa Claus (and Champagne) shows me the light!

# Bouding Box

First simple idea was to use bounding box to have a simple check before deciding to call costly function getCollisionWith. The bounding box is defined by a topLeft and a bottomRight points, by combining xy pos and then xy + v and taking account object radius.

We only need to call getCollisionWith if bounding box overlap, otherwise ther is no need to. But this alone does not reduce the double loop complexity. The key improvement come from the next stage. Note that what we are looking for is a criteria to use to discard call to getCollisionWith when there can't be any collision at all.

( Diagram here )

# Indexing the 2D plan

Wouldn't it be cool if we could stop the second loop, when there is no more collsiion pssible with the current object from the main loop ?

We coud do that if we had a mapping from the 2D plane to one dimensionnal incex with the property that given index( mainBox) < index( otherBox) then no more collision are possible.

## Hilbert Curve 

The idea jump to my sofa, was from an xkcd article which [mapped the internet](https://www.xkcd.com/195/) using [Hilbert curve](https://en.wikipedia.org/wiki/Hilbert_curve) that I remembered then. But it was not suitable here: while Hilbert coordinate have the propety to ussually keep locality (point in plane that are close stay close in general with Hilbert index) they are difficult to compute and they don't fit this problem well. Fotunately wikipedia gave me hint to other [space filling curves]({% post_url 2017-12-29-Space-filling-curve %}), one being the [Z-order curve](https://en.wikipedia.org/wiki/Z-order_(curve)) from Morton.

## Z-Order curve

The Z-order curve index is built by multiplexing bits from the x and y coordinate of a point. There is [several way to implement this]({% post_url 2017-12-30-Bit-Twiddling-Hacks %}) so far I just picked one, without looking further (it doesn't show in my benchmark).

It has nice property and is used to fasten range check. 
With that in mind the collision arlgorithm became:

```
sort object by their bouding box accoring to the z-order of topLeft corner

for( int i = 0; i < NbObjects; ++i) {
    main = object[i]

    for( int j = i + 1; j < NbObjects; ++j) {
        other = object[j]

        if( other.z.topLeft > main.z.bottomRight)
            break;  // there can't be any collision with the two boxes.

        getCollisionWith( i, j);
    }
}

```

This is what I ended using with very good results. This simple test improve a lot the performance of this double loop reducing the number of iteration of the second loop to just a few.

The same 10 000 time world simulation now does:
- 290k call to getCollisionWith(),
- approx run time of 18ms

Not bad!

## Norm2

When writting this article it comes to me that the Norm2 of xy coordinates would have the same kind of properies that is usefull in the Z-order curve if we compare norm( other.topLeft) vs norm( main.bottomRight) and restricting us to the bottom right quandrant (where x and y are positive).

That's not what I have used, but I have the feeling it would be competitive, I may try it next time.
